name: Update from upstream and Publish Firefox Extension

on:
  # 定时触发（每天检查一次）
  schedule:
    - cron: '0 0 * * *'
  # 手动触发
  workflow_dispatch:
  # 如果可以配置webhook，也可以在upstream仓库更新时触发

jobs:
  update-and-publish:
    runs-on: ubuntu-latest
    environment: production  # 指定使用名为production的环境及其secrets
    steps:
      # 检出代码
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
          persist-credentials: true  # 确保凭证在后续步骤中可用

      # 设置Git配置
      - name: Configure Git
        run: |
          git config user.name 'GitHub Actions'
          git config user.email 'actions@github.com'
          # 添加upstream远程仓库
          git remote add upstream https://github.com/siyuan-note/siyuan-chrome.git || true
          git fetch upstream

      # 保存当前版本号
      - name: Save current version
        id: current_version
        run: |
          # 从manifest.json提取版本号
          VERSION=$(grep -o '"version": "[^"]*"' manifest.json | cut -d '"' -f 4)
          echo "current_version=$VERSION" >> $GITHUB_OUTPUT
          echo "当前版本: $VERSION"

      # 拉取并合并upstream代码
      - name: Pull and merge from upstream
        run: |
          # 切换到main分支
          git checkout main
          # 设置默认合并策略
          git config pull.rebase false
          # 拉取upstream代码
          git pull upstream main -X theirs --no-edit

      # 转换Chrome API为Firefox API
      - name: Convert Chrome API to Firefox API
        run: |
          # 执行类似我们脚本中的API转换逻辑
          find . -type f -name "*.js" -not -path "*/node_modules/*" -not -path "*/\.*" | while read file; do
            echo "处理文件: $file"
            # 替换chrome API为browser API
            sed -i 's/chrome\./browser\./g' "$file"
          done

      # 检查版本号是否变化
      - name: Check for version change
        id: version_check
        run: |
          # 从更新后的manifest.json提取版本号
          NEW_VERSION=$(grep -o '"version": "[^"]*"' manifest.json | cut -d '"' -f 4)
          echo "新的版本: $NEW_VERSION"
          
          # 比较版本号
          if [ "${{ steps.current_version.outputs.current_version }}" != "$NEW_VERSION" ]; then
            echo "版本已更新！"
            echo "version_changed=true" >> $GITHUB_OUTPUT
            echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          else
            echo "版本未变化。"
            echo "version_changed=false" >> $GITHUB_OUTPUT
          fi

      # 提交并推送更改
      - name: Commit and push changes
        run: |
          # 检查当前工作目录状态（调试信息）
          echo "当前工作目录内容："
          ls -la
          
          # 显示git状态（调试信息）
          echo "Git状态："
          git status
          
          # 显示文件差异（调试信息）
          echo "最近的文件更改："
          git diff --name-only || true
          
          # 添加所有更改
          git add .
          
          # 强制添加manifest.json（确保版本更新被捕获）
          git add manifest.json
          
          # 再次检查git状态（调试信息）
          echo "添加后Git状态："
          git status
          
          # 检查是否有更改
          if git diff --staged --quiet; then
            echo "没有任何更改需要提交。"
            # 显示暂存区状态（调试信息）
            git diff --staged || echo "暂存区确实没有更改"
          else
            echo "发现更改，准备提交..."
            git commit -m "自动提交：从upstream拉取代码并转换chrome API为browser API"
            echo "准备推送更改..."
            git push origin main -f || echo "推送失败，可能需要更高级的权限"
            echo "更改已成功推送到仓库。"
          fi
      
      # 安装Firefox扩展打包工具
      - name: Install web-ext
        if: steps.version_check.outputs.version_changed == 'true'
        run: |
          npm install --global web-ext

      # 打包Firefox扩展
      - name: Build Firefox extension
        if: steps.version_check.outputs.version_changed == 'true'
        run: |
          web-ext build --no-input
          echo "打包完成，扩展文件位于web-ext-artifacts/目录"

      # 发布到Firefox Add-ons Store
      - name: Publish to Firefox Add-ons
        if: steps.version_check.outputs.version_changed == 'true'
        run: |
          echo "将使用Mozilla Add-ons API发布扩展..."
          # 注意：需要设置Mozilla Add-ons API密钥和密码
          web-ext sign --api-key ${{ secrets.MOZILLA_API_KEY }} --api-secret ${{ secrets.MOZILLA_API_SECRET }} --channel listed
        env:
          NODE_ENV: production